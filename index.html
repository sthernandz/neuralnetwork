<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mapa Conceptual SVM - Visor VR</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Inter, Arial, sans-serif; }
        canvas { display:block }
        #info { position:absolute; top:10px; width:100%; text-align:center; z-index:100; font-size:1.05rem; }
        #mobile-controls { position:fixed; bottom:20px; left:20px; z-index:200; display:none }
        .control-pad { display:grid; grid-template-columns:repeat(3,56px); grid-template-rows:repeat(3,56px); gap:8px }
        .control-btn { background:rgba(0,136,255,0.25); border:2px solid rgba(0,136,255,0.7); border-radius:10px; color:#fff; font-size:20px; display:flex; align-items:center; justify-content:center; }
        .control-btn:active{ transform:scale(.96) }
        .control-btn.center{ opacity:0; pointer-events:none }
        #gyro-btn { position:fixed; top:18px; right:18px; z-index:200; padding:10px 14px; background:rgba(170,0,255,0.45); border:2px solid rgba(170,0,255,0.85); border-radius:8px; color:#fff; font-size:13px; display:none }
    </style>
</head>
<body>
    <div id="info">Mapa Conceptual de SVM — Visor VR</div>
    <button id="gyro-btn">Activar Giroscopio</button>
    <div id="mobile-controls">
        <div class="control-pad">
            <div class="control-btn" id="btn-up">↑</div>
            <div class="control-btn center"></div>
            <div class="control-btn" id="btn-left">←</div>
            <div class="control-btn" id="btn-down">↓</div>
            <div class="control-btn" id="btn-right">→</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { DeviceOrientationControls } from 'three/addons/controls/DeviceOrientationControls.js';

        // Parámetros
        const NETWORK_RADIUS = 600;
        const BLOOM_LAYER = 1;

        // Datos (idénticos a su versión original)
        const concepts = [
            { id: 'svm', name: 'Support Vector Machine (SVM)', category: 'algorithm' },
            { id: 'supervised', name: 'Aprendizaje Supervisado', category: 'problem_type' },
            { id: 'classification', name: 'Clasificación', category: 'problem_type' },
            { id: 'regression', name: 'Regresión', category: 'problem_type' },
            { id: 'hyperplane', name: 'Hiperplano', category: 'fundamental' },
            { id: 'margin', name: 'Margen', category: 'fundamental' },
            { id: 'support_vectors', name: 'Vectores de Soporte', category: 'fundamental' },
            { id: 'linear_classification', name: 'Clasificación Lineal', category: 'technique' },
            { id: 'nonlinear_classification', name: 'Clasificación No Lineal', category: 'technique' },
            { id: 'hard_margin', name: 'Clasificación "Hard Margin"', category: 'technique' },
            { id: 'soft_margin', name: 'Clasificación "Soft Margin"', category: 'technique' },
            { id: 'kernel_trick', name: 'Truco Kernel', category: 'technique' },
            { id: 'kernel_functions', name: 'Funciones Kernel', category: 'implementation' },
            { id: 'poly_kernel', name: 'Kernel Polinomial', category: 'implementation' },
            { id: 'rbf_kernel', name: 'Kernel RBF Gaussiano', category: 'implementation' },
            { id: 'sigmoid_kernel', name: 'Kernel Sigmoideo', category: 'implementation' },
            { id: 'scikit_learn', name: 'Scikit-Learn', category: 'implementation' },
            { id: 'outliers', name: 'Outliers', category: 'challenge' },
            { id: 'param_c', name: 'Parámetro C (Regularización)', category: 'challenge' },
            { id: 'overfitting', name: 'Overfitting', category: 'challenge' },
            { id: 'param_epsilon', name: 'Parámetro Épsilon (ε)', category: 'challenge' },
            { id: 'param_degree', name: 'Grado (d)', category: 'challenge' }
        ];

        const relationships = [
            { source: 'svm', target: 'supervised', label: 'es un tipo de' },
            { source: 'svm', target: 'classification', label: 'se aplica a' },
            { source: 'svm', target: 'regression', label: 'se aplica a' },
            { source: 'classification', target: 'linear_classification', label: 'puede ser' },
            { source: 'classification', target: 'nonlinear_classification', label: 'puede ser' },
            { source: 'linear_classification', target: 'hyperplane', label: 'busca un' },
            { source: 'hyperplane', target: 'margin', label: 'que maximiza el' },
            { source: 'margin', target: 'support_vectors', label: 'definido por los' },
            { source: 'linear_classification', target: 'hard_margin', label: 'variante' },
            { source: 'linear_classification', target: 'soft_margin', label: 'variante' },
            { source: 'hard_margin', target: 'outliers', label: 'es sensible a' },
            { source: 'soft_margin', target: 'param_c', label: 'controlado por' },
            { source: 'param_c', target: 'overfitting', label: 'un valor alto causa' },
            { source: 'nonlinear_classification', target: 'kernel_trick', label: 'usa el' },
            { source: 'kernel_trick', target: 'kernel_functions', label: 'se implementa con' },
            { source: 'kernel_functions', target: 'poly_kernel', label: 'tipo' },
            { source: 'kernel_functions', target: 'rbf_kernel', label: 'tipo' },
            { source: 'kernel_functions', target: 'sigmoid_kernel', label: 'tipo' },
            { source: 'poly_kernel', target: 'param_degree', label: 'controlado por' },
            { source: 'param_degree', target: 'overfitting', label: 'un grado alto causa' },
            { source: 'regression', target: 'margin', label: 'busca ajustar en el' },
            { source: 'regression', target: 'param_epsilon', label: 'controlado por' },
            { source: 'svm', target: 'scikit_learn', label: 'se implementa en' }
        ];

        const categoryColors = {
            algorithm: new THREE.Color(0x0088ff),
            problem_type: new THREE.Color(0x00ff88),
            fundamental: new THREE.Color(0xff8800),
            technique: new THREE.Color(0xaa00ff),
            implementation: new THREE.Color(0xcccccc),
            challenge: new THREE.Color(0xff0044)
        };

        // Escena, cámara y renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 50);
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloom);

        // luces
        scene.add(new THREE.AmbientLight(0x404040));
        const pointLight = new THREE.PointLight(0xffffff, 1, 2000);
        scene.add(pointLight);

        // helpers: texto como sprite
        function makeTextSprite(message, opts = {}){
            const fontface = opts.fontface || 'Arial';
            const fontsize = opts.fontsize || 20;
            const color = opts.textColor || { r:255,g:255,b:255,a:1 };
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = ctx.measureText(message);
            const w = Math.ceil(metrics.width)+10;
            const h = fontsize+10;
            canvas.width = w; canvas.height = h;
            ctx.font = `Bold ${fontsize}px ${fontface}`;
            ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;
            ctx.fillText(message, 5, fontsize-2);
            const tex = new THREE.Texture(canvas); tex.needsUpdate = true;
            const mat = new THREE.SpriteMaterial({ map: tex });
            const spr = new THREE.Sprite(mat);
            spr.scale.set(w/4, h/4, 1);
            return spr;
        }

        // crear nodos y enlaces
        const nodeObjects = new Map();
        const nodeGeom = new THREE.SphereGeometry(3, 24, 24);

        concepts.forEach(c => {
            const color = categoryColors[c.category] || new THREE.Color(0xffffff);
            const mat = new THREE.MeshBasicMaterial({ color });
            const mesh = new THREE.Mesh(nodeGeom, mat);
            const group = new THREE.Group();
            group.position.set((Math.random()-0.5)*NETWORK_RADIUS, (Math.random()-0.5)*NETWORK_RADIUS, (Math.random()-0.5)*NETWORK_RADIUS);
            const label = makeTextSprite(c.name, { fontsize:24, textColor:{ r: Math.floor(color.r*255), g: Math.floor(color.g*255), b: Math.floor(color.b*255), a:1}});
            label.position.set(0,6,0);
            group.add(mesh); group.add(label);
            group.layers.enable(BLOOM_LAYER);
            scene.add(group);
            nodeObjects.set(c.id, group);
        });

        relationships.forEach(rel=>{
            const a = nodeObjects.get(rel.source);
            const b = nodeObjects.get(rel.target);
            if(!a||!b) return;
            const pts = [a.position.clone(), b.position.clone()];
            const geom = new THREE.BufferGeometry().setFromPoints(pts);
            const mat = new THREE.LineBasicMaterial({ color: a.children[0].material.color, transparent:true, opacity:0.7 });
            const line = new THREE.Line(geom, mat);
            line.layers.enable(BLOOM_LAYER);
            scene.add(line);
            const mid = new THREE.Vector3().addVectors(a.position, b.position).multiplyScalar(0.5);
            const lbl = makeTextSprite(rel.label, { fontsize:16, textColor:{ r:0,g:200,b:200,a:0.9 }});
            lbl.position.copy(mid);
            lbl.layers.enable(BLOOM_LAYER);
            scene.add(lbl);
        });

        // controles y navegación estilo "visor VR" con rotaciones infinitas
        let deviceControls = null;
        let gyroActive = false;

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if(isMobile){ document.getElementById('mobile-controls').style.display='block'; document.getElementById('gyro-btn').style.display='block'; }

        // movimiento de la "cámara jugador" (traslaciones)
        const keyboard = {}; const touchControls = { up:false, down:false, left:false, right:false };
        const playerSpeed = 2.0; const mouseRotationSpeed = 0.0025;

        document.addEventListener('keydown', e => keyboard[e.key.toLowerCase()]=true);
        document.addEventListener('keyup', e => keyboard[e.key.toLowerCase()]=false);

        // touch buttons
        function setupTouchControl(btnId, dir){ const btn=document.getElementById(btnId); btn.addEventListener('touchstart', e=>{ e.preventDefault(); touchControls[dir]=true }); btn.addEventListener('touchend', e=>{ e.preventDefault(); touchControls[dir]=false }); }
        setupTouchControl('btn-up','up'); setupTouchControl('btn-down','down'); setupTouchControl('btn-left','left'); setupTouchControl('btn-right','right');

        // Giroscopio: usa DeviceOrientationControls para mapear alpha/beta/gamma a quaternion de cámara
        const gyroBtn = document.getElementById('gyro-btn');
        async function enableGyro(){
            if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
                try{
                    const perm = await DeviceOrientationEvent.requestPermission();
                    if(perm !== 'granted') throw new Error('perm denied');
                }catch(err){ alert('Permiso de giroscopio denegado o no disponible'); return; }
            }
            if(!deviceControls){ deviceControls = new DeviceOrientationControls(camera); deviceControls.connect(); }
            gyroActive = true; gyroBtn.textContent = 'Giroscopio Activo'; gyroBtn.style.background='rgba(0,255,136,0.45)';
        }
        gyroBtn.addEventListener('click', enableGyro);

        // ROTACIONES POR RATÓN (desktop) usando pointer lock y rotación por ejes del mundo
        const rotationAxis = new THREE.Vector3(0,1,0);
        document.addEventListener('mousemove', (ev)=>{
            if(document.pointerLockElement === document.body && !gyroActive){
                const mx = ev.movementX || 0; const my = ev.movementY || 0;
                // yaw (rotación alrededor del eje Y global)
                camera.rotateOnWorldAxis(rotationAxis, -mx * mouseRotationSpeed);
                // pitch (rotación local X)
                camera.rotateX(-my * mouseRotationSpeed);
            }
        });

        // Habilitar pointer lock con click en desktop
        if(!isMobile){ document.addEventListener('click', ()=>{ if(document.pointerLockElement!==document.body) document.body.requestPointerLock(); }); }

        // Touch drag para rotar (mobile cuando no se usa giroscopio)
        let lastTouch = null;
        window.addEventListener('touchstart', e=>{ if(e.touches.length===1){ lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } });
        window.addEventListener('touchmove', e=>{
            if(e.touches.length===1 && !gyroActive && lastTouch){
                const t = e.touches[0];
                const dx = t.clientX - lastTouch.x; const dy = t.clientY - lastTouch.y;
                camera.rotateOnWorldAxis(rotationAxis, -dx * mouseRotationSpeed);
                camera.rotateX(-dy * mouseRotationSpeed);
                lastTouch = { x: t.clientX, y: t.clientY };
            }
        }, { passive:false });
        window.addEventListener('touchend', ()=>{ lastTouch = null; });

        // actualización de movimiento
        function updateMovement(){
            if(keyboard['w'] || keyboard['arrowup'] || touchControls.up) camera.translateZ(-playerSpeed);
            if(keyboard['s'] || keyboard['arrowdown'] || touchControls.down) camera.translateZ(playerSpeed);
            if(keyboard['a'] || keyboard['arrowleft'] || touchControls.left) camera.translateX(-playerSpeed);
            if(keyboard['d'] || keyboard['arrowright'] || touchControls.right) camera.translateX(playerSpeed);
        }

        // mantener los labels mirando a la cámara
        function faceLabels(){ nodeObjects.forEach(node=>{ const label=node.children[1]; if(label) label.quaternion.copy(camera.quaternion); }); }

        // loop de animación
        function animate(){
            requestAnimationFrame(animate);
            updateMovement();
            pointLight.position.copy(camera.position);
            faceLabels();
            if(gyroActive && deviceControls) deviceControls.update();
            composer.render();
        }

        // resize
        window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); });

        animate();
    </script>
</body>
</html>
