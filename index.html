<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mapa Conceptual de SVM en 3D</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            font-size: 1.2em;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        
        /* Controles móviles */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 200;
            display: none;
        }
        
        .control-pad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(0, 136, 255, 0.3);
            border: 2px solid rgba(0, 136, 255, 0.8);
            border-radius: 10px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.5);
            transition: all 0.1s;
        }
        
        .control-btn:active {
            background: rgba(0, 136, 255, 0.6);
            transform: scale(0.95);
        }
        
        .control-btn.center {
            grid-column: 2;
            grid-row: 2;
            opacity: 0;
            pointer-events: none;
        }
        
        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-down { grid-column: 2; grid-row: 3; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }
        
        #gyro-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 200;
            padding: 10px 20px;
            background: rgba(170, 0, 255, 0.5);
            border: 2px solid rgba(170, 0, 255, 0.8);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: none;
            box-shadow: 0 0 10px rgba(170, 0, 255, 0.5);
        }
        
        #gyro-btn:active {
            background: rgba(170, 0, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="info">Mapa Conceptual de SVM</div>
    
    <button id="gyro-btn">Activar Giroscopio</button>
    
    <div id="mobile-controls">
        <div class="control-pad">
            <div class="control-btn" id="btn-up">↑</div>
            <div class="control-btn center"></div>
            <div class="control-btn" id="btn-left">←</div>
            <div class="control-btn" id="btn-down">↓</div>
            <div class="control-btn" id="btn-right">→</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN DEL MAPA CONCEPTUAL ---
        const NETWORK_RADIUS = 600;

        const concepts = [
            { id: 'svm', name: 'Support Vector Machine (SVM)', category: 'algorithm' },
            { id: 'supervised', name: 'Aprendizaje Supervisado', category: 'problem_type' },
            { id: 'classification', name: 'Clasificación', category: 'problem_type' },
            { id: 'regression', name: 'Regresión', category: 'problem_type' },
            { id: 'hyperplane', name: 'Hiperplano', category: 'fundamental' },
            { id: 'margin', name: 'Margen', category: 'fundamental' },
            { id: 'support_vectors', name: 'Vectores de Soporte', category: 'fundamental' },
            { id: 'linear_classification', name: 'Clasificación Lineal', category: 'technique' },
            { id: 'nonlinear_classification', name: 'Clasificación No Lineal', category: 'technique' },
            { id: 'hard_margin', name: 'Clasificación "Hard Margin"', category: 'technique' },
            { id: 'soft_margin', name: 'Clasificación "Soft Margin"', category: 'technique' },
            { id: 'kernel_trick', name: 'Truco Kernel', category: 'technique' },
            { id: 'kernel_functions', name: 'Funciones Kernel', category: 'implementation' },
            { id: 'poly_kernel', name: 'Kernel Polinomial', category: 'implementation' },
            { id: 'rbf_kernel', name: 'Kernel RBF Gaussiano', category: 'implementation' },
            { id: 'sigmoid_kernel', name: 'Kernel Sigmoideo', category: 'implementation' },
            { id: 'scikit_learn', name: 'Scikit-Learn', category: 'implementation' },
            { id: 'outliers', name: 'Outliers', category: 'challenge' },
            { id: 'param_c', name: 'Parámetro C (Regularización)', category: 'challenge' },
            { id: 'overfitting', name: 'Overfitting', category: 'challenge' },
            { id: 'param_epsilon', name: 'Parámetro Épsilon (ε)', category: 'challenge' },
            { id: 'param_degree', name: 'Grado (d)', category: 'challenge' }
        ];

        const relationships = [
            { source: 'svm', target: 'supervised', label: 'es un tipo de' },
            { source: 'svm', target: 'classification', label: 'se aplica a' },
            { source: 'svm', target: 'regression', label: 'se aplica a' },
            { source: 'classification', target: 'linear_classification', label: 'puede ser' },
            { source: 'classification', target: 'nonlinear_classification', label: 'puede ser' },
            { source: 'linear_classification', target: 'hyperplane', label: 'busca un' },
            { source: 'hyperplane', target: 'margin', label: 'que maximiza el' },
            { source: 'margin', target: 'support_vectors', label: 'definido por los' },
            { source: 'linear_classification', target: 'hard_margin', label: 'variante' },
            { source: 'linear_classification', target: 'soft_margin', label: 'variante' },
            { source: 'hard_margin', target: 'outliers', label: 'es sensible a' },
            { source: 'soft_margin', target: 'param_c', label: 'controlado por' },
            { source: 'param_c', target: 'overfitting', label: 'un valor alto causa' },
            { source: 'nonlinear_classification', target: 'kernel_trick', label: 'usa el' },
            { source: 'kernel_trick', target: 'kernel_functions', label: 'se implementa con' },
            { source: 'kernel_functions', target: 'poly_kernel', label: 'tipo' },
            { source: 'kernel_functions', target: 'rbf_kernel', label: 'tipo' },
            { source: 'kernel_functions', target: 'sigmoid_kernel', label: 'tipo' },
            { source: 'poly_kernel', target: 'param_degree', label: 'controlado por' },
            { source: 'param_degree', target: 'overfitting', label: 'un grado alto causa' },
            { source: 'regression', target: 'margin', label: 'busca ajustar en el' },
            { source: 'regression', target: 'param_epsilon', label: 'controlado por' },
            { source: 'svm', target: 'scikit_learn', label: 'se implementa en' }
        ];

        const categoryColors = {
            algorithm: new THREE.Color(0x0088ff),
            problem_type: new THREE.Color(0x00ff88),
            fundamental: new THREE.Color(0xff8800),
            technique: new THREE.Color(0xaa00ff),
            implementation: new THREE.Color(0xcccccc),
            challenge: new THREE.Color(0xff0044)
        };

        // --- INICIALIZACIÓN DE LA ESCENA 3D ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 50;
        camera.rotation.order = 'YXZ';
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING PARA EL EFECTO GLOW (BLOOM) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const BLOOM_LAYER = 1;

        // --- LUCES ---
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 2000);
        scene.add(pointLight);

        // --- FUNCIÓN PARA CREAR TEXTO (SPRITES) ---
        function makeTextSprite(message, opts) {
            const parameters = opts || {};
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const textColor = parameters.textColor || { r: 255, g: 255, b: 255, a: 1.0 };
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            canvas.width = textWidth + 10;
            canvas.height = fontsize + 10;
            context.font = `Bold ${fontsize}px ${fontface}`;
            context.fillStyle = `rgba(${textColor.r}, ${textColor.g}, ${textColor.b}, ${textColor.a})`;
            context.fillText(message, 5, fontsize - 2);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 4, canvas.height / 4, 1.0);
            return sprite;
        }

        // --- CREACIÓN DEL MAPA CONCEPTUAL 3D ---
        const nodeObjects = new Map();
        const nodeGeometry = new THREE.SphereGeometry(3, 24, 24);

        concepts.forEach(concept => {
            const color = categoryColors[concept.category] || new THREE.Color(0xffffff);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const nodeMesh = new THREE.Mesh(nodeGeometry, material);
            
            const nodeGroup = new THREE.Group();
            nodeGroup.position.x = (Math.random() - 0.5) * NETWORK_RADIUS;
            nodeGroup.position.y = (Math.random() - 0.5) * NETWORK_RADIUS;
            nodeGroup.position.z = (Math.random() - 0.5) * NETWORK_RADIUS;
            
            const labelSprite = makeTextSprite(concept.name, {
                fontsize: 24,
                textColor: { r: color.r * 255, g: color.g * 255, b: color.b * 255, a: 1.0 }
            });
            labelSprite.position.set(0, 6, 0);

            nodeGroup.add(nodeMesh);
            nodeGroup.add(labelSprite);
            nodeGroup.layers.enable(BLOOM_LAYER);
            
            scene.add(nodeGroup);
            nodeObjects.set(concept.id, nodeGroup);
        });

        relationships.forEach(rel => {
            const startNode = nodeObjects.get(rel.source);
            const endNode = nodeObjects.get(rel.target);
            if (!startNode || !endNode) return;

            const startColor = startNode.children[0].material.color;
            const points = [startNode.position, endNode.position];
            const linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const linkMaterial = new THREE.LineBasicMaterial({ color: startColor, transparent: true, opacity: 0.7 });
            const line = new THREE.Line(linkGeometry, linkMaterial);
            line.layers.enable(BLOOM_LAYER);
            scene.add(line);

            const midpoint = new THREE.Vector3().addVectors(startNode.position, endNode.position).multiplyScalar(0.5);
            const unionSprite = makeTextSprite(rel.label, {
                fontsize: 16,
                textColor: { r: 0, g: 200, b: 200, a: 0.9 }
            });
            unionSprite.position.copy(midpoint);
            unionSprite.layers.enable(BLOOM_LAYER);
            scene.add(unionSprite);
        });

        // --- CONTROLES ---
        const keyboard = {};
        const playerSpeed = 2.0;
        const rotationSpeed = 0.002;

        // Detectar dispositivo móvil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('gyro-btn').style.display = 'block';
        }

        // --- CONTROLES DE TECLADO ---
        document.addEventListener('keydown', (e) => keyboard[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keyboard[e.key.toLowerCase()] = false);

        // --- CONTROLES TÁCTILES ---
        const touchControls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        function setupTouchControl(btnId, direction) {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls[direction] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls[direction] = false;
            });
        }

        setupTouchControl('btn-up', 'up');
        setupTouchControl('btn-down', 'down');
        setupTouchControl('btn-left', 'left');
        setupTouchControl('btn-right', 'right');

        // --- GIROSCOPIO ---
        let gyroEnabled = false;
        let baseOrientation = null;

        async function enableGyro() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requiere permiso
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        startGyro();
                    }
                } catch (error) {
                    console.error('Error al solicitar permiso:', error);
                    alert('No se pudo activar el giroscopio');
                }
            } else {
                // Android y otros navegadores
                startGyro();
            }
        }

        function startGyro() {
            gyroEnabled = true;
            baseOrientation = null;
            document.getElementById('gyro-btn').textContent = 'Giroscopio Activo';
            document.getElementById('gyro-btn').style.background = 'rgba(0, 255, 136, 0.5)';
            
            window.addEventListener('deviceorientation', handleOrientation);
        }

        function handleOrientation(event) {
            if (!gyroEnabled) return;

            const alpha = event.alpha || 0; // Rotación Z (brújula)
            const beta = event.beta || 0;   // Rotación X (inclinación frontal)
            const gamma = event.gamma || 0; // Rotación Y (inclinación lateral)
            
            // Guardar orientación base en el primer frame
            if (baseOrientation === null) {
                baseOrientation = {
                    alpha: alpha,
                    beta: beta,
                    gamma: gamma
                };
                return;
            }
            
            // Calcular diferencias desde la orientación base
            let deltaAlpha = alpha - baseOrientation.alpha;
            let deltaBeta = beta - baseOrientation.beta;
            let deltaGamma = gamma - baseOrientation.gamma;
            
            // Manejar el wraparound del alpha (0-360 grados)
            if (deltaAlpha > 180) deltaAlpha -= 360;
            if (deltaAlpha < -180) deltaAlpha += 360;
            
            // Convertir a radianes y aplicar a la cámara
            // Alpha: DESACTIVADO - no usamos la brújula
            // camera.rotation.y = deltaAlpha * Math.PI / 180;
            
            // Beta: mirar arriba/abajo (pitch) - SIN límites para permitir 360°
            camera.rotation.x = deltaBeta * Math.PI / 180;
            
            // Gamma controla la rotación horizontal (reemplaza al alpha)
            camera.rotation.y = -deltaGamma * Math.PI / 180;
        }

        document.getElementById('gyro-btn').addEventListener('click', enableGyro);

        // --- CONTROL DE RATÓN (DESKTOP) ---
        document.addEventListener('mousemove', onDocumentMouseMove);

        function onDocumentMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * rotationSpeed;
                camera.rotation.x -= event.movementY * rotationSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function updatePlayer() {
            // Controles de teclado
            if (keyboard['w'] || keyboard['arrowup']) camera.translateZ(-playerSpeed);
            if (keyboard['s'] || keyboard['arrowdown']) camera.translateZ(playerSpeed);
            if (keyboard['a'] || keyboard['arrowleft']) camera.translateX(-playerSpeed);
            if (keyboard['d'] || keyboard['arrowright']) camera.translateX(playerSpeed);
            
            // Controles táctiles
            if (touchControls.up) camera.translateZ(-playerSpeed);
            if (touchControls.down) camera.translateZ(playerSpeed);
            if (touchControls.left) camera.translateX(-playerSpeed);
            if (touchControls.right) camera.translateX(playerSpeed);
        }
        
        // --- LOOP DE ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            pointLight.position.copy(camera.position);

            nodeObjects.forEach(node => {
                const label = node.children[1];
                if (label) {
                    label.quaternion.copy(camera.quaternion);
                }
            });

            composer.render();
        }

        // --- MANEJO DE VENTANA ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        if (!isMobile) {
            document.addEventListener('click', () => {
                document.body.requestPointerLock();
            });
        }

        animate();
    </script>
</body>
</html>
