<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mapa Conceptual de SVM en 3D</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            font-size: 1.2em;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        
        /* Controles móviles */
        .control-btn {
            position: fixed;
            background: rgba(0, 136, 255, 0.3);
            border: 2px solid rgba(0, 136, 255, 0.8);
            border-radius: 15px;
            color: white;
            font-size: 32px;
            width: 70px;
            height: 70px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 15px rgba(0, 136, 255, 0.5);
            transition: all 0.1s;
            z-index: 200;
        }
        
        .control-btn:active {
            background: rgba(0, 136, 255, 0.6);
            transform: scale(0.95);
        }
        
        #btn-up { 
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
        }
        
        #btn-down { 
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
        }
        
        #btn-left { 
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
        }
        
        #btn-right { 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #gyro-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 200;
            padding: 10px 20px;
            background: rgba(170, 0, 255, 0.5);
            border: 2px solid rgba(170, 0, 255, 0.8);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: none;
            box-shadow: 0 0 10px rgba(170, 0, 255, 0.5);
        }
        
        #gyro-btn:active {
            background: rgba(170, 0, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="info">Mapa Conceptual de SVM</div>
    
    <button id="gyro-btn">Activar Giroscopio</button>
    
    <div class="control-btn" id="btn-up">↑</div>
    <div class="control-btn" id="btn-down">↓</div>
    <div class="control-btn" id="btn-left">←</div>
    <div class="control-btn" id="btn-right">→</div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN DEL MAPA CONCEPTUAL ---
        const NETWORK_RADIUS = 600;

        const concepts = [
            { id: 'svm', name: 'Support Vector Machine (SVM)', category: 'algorithm' },
            { id: 'supervised', name: 'Aprendizaje Supervisado', category: 'problem_type' },
            { id: 'classification', name: 'Clasificación', category: 'problem_type' },
            { id: 'regression', name: 'Regresión', category: 'problem_type' },
            { id: 'hyperplane', name: 'Hiperplano', category: 'fundamental' },
            { id: 'margin', name: 'Margen', category: 'fundamental' },
            { id: 'support_vectors', name: 'Vectores de Soporte', category: 'fundamental' },
            { id: 'linear_classification', name: 'Clasificación Lineal', category: 'technique' },
            { id: 'nonlinear_classification', name: 'Clasificación No Lineal', category: 'technique' },
            { id: 'hard_margin', name: 'Clasificación "Hard Margin"', category: 'technique' },
            { id: 'soft_margin', name: 'Clasificación "Soft Margin"', category: 'technique' },
            { id: 'kernel_trick', name: 'Truco Kernel', category: 'technique' },
            { id: 'kernel_functions', name: 'Funciones Kernel', category: 'implementation' },
            { id: 'poly_kernel', name: 'Kernel Polinomial', category: 'implementation' },
            { id: 'rbf_kernel', name: 'Kernel RBF Gaussiano', category: 'implementation' },
            { id: 'sigmoid_kernel', name: 'Kernel Sigmoideo', category: 'implementation' },
            { id: 'scikit_learn', name: 'Scikit-Learn', category: 'implementation' },
            { id: 'outliers', name: 'Outliers', category: 'challenge' },
            { id: 'param_c', name: 'Parámetro C (Regularización)', category: 'challenge' },
            { id: 'overfitting', name: 'Overfitting', category: 'challenge' },
            { id: 'param_epsilon', name: 'Parámetro Épsilon (ε)', category: 'challenge' },
            { id: 'param_degree', name: 'Grado (d)', category: 'challenge' }
        ];

        const relationships = [
            { source: 'svm', target: 'supervised', label: 'es un tipo de' },
            { source: 'svm', target: 'classification', label: 'se aplica a' },
            { source: 'svm', target: 'regression', label: 'se aplica a' },
            { source: 'classification', target: 'linear_classification', label: 'puede ser' },
            { source: 'classification', target: 'nonlinear_classification', label: 'puede ser' },
            { source: 'linear_classification', target: 'hyperplane', label: 'busca un' },
            { source: 'hyperplane', target: 'margin', label: 'que maximiza el' },
            { source: 'margin', target: 'support_vectors', label: 'definido por los' },
            { source: 'linear_classification', target: 'hard_margin', label: 'variante' },
            { source: 'linear_classification', target: 'soft_margin', label: 'variante' },
            { source: 'hard_margin', target: 'outliers', label: 'es sensible a' },
            { source: 'soft_margin', target: 'param_c', label: 'controlado por' },
            { source: 'param_c', target: 'overfitting', label: 'un valor alto causa' },
            { source: 'nonlinear_classification', target: 'kernel_trick', label: 'usa el' },
            { source: 'kernel_trick', target: 'kernel_functions', label: 'se implementa con' },
            { source: 'kernel_functions', target: 'poly_kernel', label: 'tipo' },
            { source: 'kernel_functions', target: 'rbf_kernel', label: 'tipo' },
            { source: 'kernel_functions', target: 'sigmoid_kernel', label: 'tipo' },
            { source: 'poly_kernel', target: 'param_degree', label: 'controlado por' },
            { source: 'param_degree', target: 'overfitting', label: 'un grado alto causa' },
            { source: 'regression', target: 'margin', label: 'busca ajustar en el' },
            { source: 'regression', target: 'param_epsilon', label: 'controlado por' },
            { source: 'svm', target: 'scikit_learn', label: 'se implementa en' }
        ];

        const categoryColors = {
            algorithm: new THREE.Color(0x0088ff),
            problem_type: new THREE.Color(0x00ff88),
            fundamental: new THREE.Color(0xff8800),
            technique: new THREE.Color(0xaa00ff),
            implementation: new THREE.Color(0xcccccc),
            challenge: new THREE.Color(0xff0044)
        };

        // --- INICIALIZACIÓN DE LA ESCENA 3D ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 50;
        camera.rotation.order = 'YXZ';
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING PARA EL EFECTO GLOW (BLOOM) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const BLOOM_LAYER = 1;

        // --- LUCES ---
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 2000);
        scene.add(pointLight);

        // --- FUNCIÓN PARA CREAR TEXTO (SPRITES) ---
        function makeTextSprite(message, opts) {
            const parameters = opts || {};
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const textColor = parameters.textColor || { r: 255, g: 255, b: 255, a: 1.0 };
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            canvas.width = textWidth + 10;
            canvas.height = fontsize + 10;
            context.font = `Bold ${fontsize}px ${fontface}`;
            context.fillStyle = `rgba(${textColor.r}, ${textColor.g}, ${textColor.b}, ${textColor.a})`;
            context.fillText(message, 5, fontsize - 2);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 4, canvas.height / 4, 1.0);
            return sprite;
        }

        // --- CREACIÓN DEL MAPA CONCEPTUAL 3D ---
        const nodeObjects = new Map();
        const nodeGeometry = new THREE.SphereGeometry(3, 24, 24);

        concepts.forEach(concept => {
            const color = categoryColors[concept.category] || new THREE.Color(0xffffff);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const nodeMesh = new THREE.Mesh(nodeGeometry, material);
            
            const nodeGroup = new THREE.Group();
            nodeGroup.position.x = (Math.random() - 0.5) * NETWORK_RADIUS;
            nodeGroup.position.y = (Math.random() - 0.5) * NETWORK_RADIUS;
            nodeGroup.position.z = (Math.random() - 0.5) * NETWORK_RADIUS;
            
            const labelSprite = makeTextSprite(concept.name, {
                fontsize: 24,
                textColor: { r: color.r * 255, g: color.g * 255, b: color.b * 255, a: 1.0 }
            });
            labelSprite.position.set(0, 6, 0);

            nodeGroup.add(nodeMesh);
            nodeGroup.add(labelSprite);
            nodeGroup.layers.enable(BLOOM_LAYER);
            
            scene.add(nodeGroup);
            nodeObjects.set(concept.id, nodeGroup);
        });

        relationships.forEach(rel => {
            const startNode = nodeObjects.get(rel.source);
            const endNode = nodeObjects.get(rel.target);
            if (!startNode || !endNode) return;

            const startColor = startNode.children[0].material.color;
            const points = [startNode.position, endNode.position];
            const linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const linkMaterial = new THREE.LineBasicMaterial({ color: startColor, transparent: true, opacity: 0.7 });
            const line = new THREE.Line(linkGeometry, linkMaterial);
            line.layers.enable(BLOOM_LAYER);
            scene.add(line);

            const midpoint = new THREE.Vector3().addVectors(startNode.position, endNode.position).multiplyScalar(0.5);
            const unionSprite = makeTextSprite(rel.label, {
                fontsize: 16,
                textColor: { r: 0, g: 200, b: 200, a: 0.9 }
            });
            unionSprite.position.copy(midpoint);
            unionSprite.layers.enable(BLOOM_LAYER);
            scene.add(unionSprite);
        });

        // --- CONTROLES ---
        const keyboard = {};
        const playerSpeed = 2.0;
        const rotationSpeed = 0.002;

        // Detectar dispositivo móvil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
            document.getElementById('btn-up').style.display = 'flex';
            document.getElementById('btn-down').style.display = 'flex';
            document.getElementById('btn-left').style.display = 'flex';
            document.getElementById('btn-right').style.display = 'flex';
            document.getElementById('gyro-btn').style.display = 'block';
        }

        // --- CONTROLES DE TECLADO ---
        document.addEventListener('keydown', (e) => keyboard[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keyboard[e.key.toLowerCase()] = false);

        // --- CONTROLES TÁCTILES ---
        const touchControls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        function setupTouchControl(btnId, direction) {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls[direction] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls[direction] = false;
            });
        }

        setupTouchControl('btn-up', 'up');
        setupTouchControl('btn-down', 'down');
        setupTouchControl('btn-left', 'left');
        setupTouchControl('btn-right', 'right');

        // --- GIROSCOPIO ---
        let gyroEnabled = false;
        let initialOrientation = null;
        let baseRotation = { x: 0, y: 0 };

        async function enableGyro() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requiere permiso
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        startGyro();
                    }
                } catch (error) {
                    console.error('Error al solicitar permiso:', error);
                    alert('No se pudo activar el giroscopio');
                }
            } else {
                // Android y otros navegadores
                startGyro();
            }
        }

        function startGyro() {
            gyroEnabled = true;
            initialOrientation = null;
            baseRotation.x = camera.rotation.x;
            baseRotation.y = camera.rotation.y;
            
            document.getElementById('gyro-btn').textContent = 'Giroscopio Activo';
            document.getElementById('gyro-btn').style.background = 'rgba(0, 255, 136, 0.5)';
            
            window.addEventListener('deviceorientation', handleOrientation);
        }

        function handleOrientation(event) {
            if (!gyroEnabled) return;

            const alpha = event.alpha; // Rotación Z (brújula: 0-360)
            const beta = event.beta;   // Rotación X (inclinación adelante/atrás: -180 a 180)
            const gamma = event.gamma; // Rotación Y (inclinación izquierda/derecha: -90 a 90)

            if (alpha === null || beta === null || gamma === null) return;

            // Calibración inicial
            if (initialOrientation === null) {
                initialOrientation = {
                    alpha: alpha,
                    beta: beta,
                    gamma: gamma
                };
                return;
            }

            // Detectar orientación del dispositivo (landscape)
            const isLandscape = Math.abs(gamma) > 45;
            
            if (isLandscape) {
                // Modo horizontal (landscape)
                // Convertir ángulos relativos a la posición inicial
                let deltaGamma = (gamma - initialOrientation.gamma) * Math.PI / 180;
                let deltaBeta = (beta - initialOrientation.beta) * Math.PI / 180;
                
                // Determinar si está landscape-left o landscape-right
                const landscapeRight = gamma > 0;
                
                if (landscapeRight) {
                    // Celular inclinado hacia la derecha (landscape-right)
                    camera.rotation.y = baseRotation.y - deltaBeta * 0.8;
                    camera.rotation.x = baseRotation.x + deltaGamma * 0.8;
                } else {
                    // Celular inclinado hacia la izquierda (landscape-left)
                    camera.rotation.y = baseRotation.y + deltaBeta * 0.8;
                    camera.rotation.x = baseRotation.x - deltaGamma * 0.8;
                }
            } else {
                // Modo vertical (portrait) - por si acaso
                let deltaAlpha = (alpha - initialOrientation.alpha) * Math.PI / 180;
                let deltaBeta = (beta - initialOrientation.beta) * Math.PI / 180;
                
                // Normalizar deltaAlpha para evitar saltos en el cruce de 0/360
                if (deltaAlpha > Math.PI) deltaAlpha -= 2 * Math.PI;
                if (deltaAlpha < -Math.PI) deltaAlpha += 2 * Math.PI;
                
                camera.rotation.y = baseRotation.y - deltaAlpha * 0.8;
                camera.rotation.x = baseRotation.x + deltaBeta * 0.8;
            }
            
            // Limitar rotación vertical para evitar volteretas
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        document.getElementById('gyro-btn').addEventListener('click', enableGyro);

        // --- CONTROL DE RATÓN (DESKTOP) ---
        document.addEventListener('mousemove', onDocumentMouseMove);

        function onDocumentMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * rotationSpeed;
                camera.rotation.x -= event.movementY * rotationSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function updatePlayer() {
            // Controles de teclado
            if (keyboard['w'] || keyboard['arrowup']) camera.translateZ(-playerSpeed);
            if (keyboard['s'] || keyboard['arrowdown']) camera.translateZ(playerSpeed);
            if (keyboard['a'] || keyboard['arrowleft']) camera.translateX(-playerSpeed);
            if (keyboard['d'] || keyboard['arrowright']) camera.translateX(playerSpeed);
            
            // Controles táctiles
            if (touchControls.up) camera.translateZ(-playerSpeed);
            if (touchControls.down) camera.translateZ(playerSpeed);
            if (touchControls.left) camera.translateX(-playerSpeed);
            if (touchControls.right) camera.translateX(playerSpeed);
        }
        
        // --- LOOP DE ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            pointLight.position.copy(camera.position);

            nodeObjects.forEach(node => {
                const label = node.children[1];
                if (label) {
                    label.quaternion.copy(camera.quaternion);
                }
            });

            composer.render();
        }

        // --- MANEJO DE VENTANA ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        if (!isMobile) {
            document.addEventListener('click', () => {
                document.body.requestPointerLock();
            });
        }

        animate();
    </script>
</body>
</html>
