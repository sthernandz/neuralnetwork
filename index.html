<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mapa Conceptual de Liderazgo</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            font-size: 1.2em;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        
        /* Controles móviles */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 200;
            display: none;
        }
        
        .control-pad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(0, 136, 255, 0.3);
            border: 2px solid rgba(0, 136, 255, 0.8);
            border-radius: 10px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.5);
            transition: all 0.1s;
        }
        
        .control-btn:active {
            background: rgba(0, 136, 255, 0.6);
            transform: scale(0.95);
        }
        
        .control-btn.center {
            grid-column: 2;
            grid-row: 2;
            opacity: 0;
            pointer-events: none;
        }
        
        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-down { grid-column: 2; grid-row: 3; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }
        
        #gyro-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 200;
            padding: 10px 20px;
            background: rgba(170, 0, 255, 0.5);
            border: 2px solid rgba(170, 0, 255, 0.8);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: none;
            box-shadow: 0 0 10px rgba(170, 0, 255, 0.5);
        }
        
        #gyro-btn:active {
            background: rgba(170, 0, 255, 0.8);
        }

        #debug-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            color: white;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            line-height: 1.5;
        }

        #debug-info div {
            margin-bottom: 5px;
        }
        #crosshair {
            position: fixed;
            left: 50%;
            top: 50%;
            width: 32px;
            height: 32px;
            z-index: 5000;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #crosshair:before, #crosshair:after {
            content: '';
            position: absolute;
            background: #00ffff;
            border-radius: 2px;
        }
        #crosshair:before {
            left: 50%;
            top: 0;
            width: 4px;
            height: 100%;
            transform: translateX(-50%);
            box-shadow: 0 0 8px 2px #00ffff80;
        }
        #crosshair:after {
            top: 50%;
            left: 0;
            width: 100%;
            height: 4px;
            transform: translateY(-50%);
            box-shadow: 0 0 8px 2px #00ffff80;
        }
    </style>
</head>
<body>
    <div id="info">Mapa Conceptual de Liderazgo</div>
    
    <button id="gyro-btn">Activar Giroscopio</button>

    <div id="debug-info">
        <div>Alpha: <span id="gyro-alpha">N/A</span></div>
        <div>Beta: <span id="gyro-beta">N/A</span></div>
        <div>Camera X: <span id="cam-x">N/A</span></div>
        <div>Camera Y: <span id="cam-y">N/A</span></div>
    </div>
    
    <div id="mobile-controls">
        <div class="control-pad">
            <div class="control-btn" id="btn-up">↑</div>
            <div class="control-btn center"></div>
            <div class="control-btn" id="btn-left">←</div>
            <div class="control-btn" id="btn-down">↓</div>
            <div class="control-btn" id="btn-right">→</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN DEL MAPA CONCEPTUAL ---
        const NETWORK_RADIUS = 800;

        const concepts = [
            { id: 'liderazgo', name: 'Liderazgo', category: 'root' },
            { id: 'enfoque_conductual', name: 'Enfoque Conductual', category: 'approach' },
            { id: 'ohio_state', name: 'Ohio State University', category: 'study' }, // Fixed typo
            { id: 'iniciacion_estructura', name: 'Iniciación de Estructura', category: 'concept' },
            { id: 'consideracion', name: 'Consideración', category: 'concept' },
            { id: 'liderazgo_efectivo', name: 'Liderazgo Efectivo', category: 'concept' },
            { id: 'orientacion_empleado', name: 'Orientación al Empleado', category: 'concept' },
            { id: 'orientacion_produccion', name: 'Orientación a la Producción', category: 'concept' },
            { id: 'enfoque_situacional', name: 'Enfoque Situacional', category: 'approach' },
            { id: 'contexto', name: 'Contexto Situacional', category: 'concept' },
            { id: 'hersey_blanchard', name: 'Teoría de Hersey y Blanchard', category: 'theory' },
            { id: 'nivel_desarrollo', name: 'Nivel de Desarrollo (Seguidores)', category: 'concept' },
            { id: 'delegar', name: 'Estilo: Delegar', category: 'style' },
            { id: 'entrenar', name: 'Estilo: Entrenar', category: 'style' },
            { id: 'dirigir', name: 'Estilo: Dirigir', category: 'style' },
            { id: 'apoyar', name: 'Estilo: Apoyar', category: 'style' },
            { id: 'contingencia', name: 'Teoría de la Contingencia', category: 'theory' },
            { id: 'relacion_lider_seguidor', name: 'Relación Líder-Seguidor', category: 'concept' },
            { id: 'estructura_tarea', name: 'Estructura de la Tarea', category: 'concept' },
            { id: 'poder_lider', name: 'Poder del Líder', category: 'concept' },
            { id: 'lpc', name: 'Trabajador Menos Preferido (LPC)', category: 'concept' },
            { id: 'camino_meta', name: 'Teoría del Camino-Meta', category: 'theory' },
            { id: 'motivacion', name: 'Motivación (Empleado)', category: 'concept' },
            { id: 'lider_directivo', name: 'Liderazgo Directivo (Camino-Meta)', category: 'style' },
            { id: 'lider_considerado', name: 'Liderazgo Considerado (Camino-Meta)', category: 'style' },
            { id: 'lider_participativo', name: 'Liderazgo Participativo (Camino-Meta)', category: 'style' },
            { id: 'lider_metas', name: 'Liderazgo Orientado a Metas (Camino-Meta)', category: 'style' },
            { id: 'lmx', name: 'Teoría LMX', category: 'theory' },
            { id: 'endogrupo', name: 'Endogrupo', category: 'concept' },
            { id: 'exogrupo', name: 'Exogrupo', category: 'concept' },
            { id: 'adaptar_estilo', name: 'Adaptar Estilo', category: 'concept' }
        ];

        const relationships = [
            { source: 'liderazgo', target: 'enfoque_conductual', label: 'incluye' },
            { source: 'liderazgo', target: 'enfoque_situacional', label: 'incluye' },
            { source: 'liderazgo', target: 'liderazgo_efectivo', label: 'busca' },
            
            // Enfoque Conductual
            { source: 'enfoque_conductual', target: 'ohio_state', label: 'estudiado por' },
            { source: 'ohio_state', target: 'iniciacion_estructura', label: 'define' },
            { source: 'ohio_state', target: 'consideracion', label: 'define' },
            { source: 'liderazgo_efectivo', target: 'iniciacion_estructura', label: 'requiere' },
            { source: 'liderazgo_efectivo', target: 'consideracion', label: 'requiere' },
            { source: 'enfoque_conductual', target: 'orientacion_empleado', label: 'identifica' },
            { source: 'enfoque_conductual', target: 'orientacion_produccion', label: 'identifica' },

            // Enfoque Situacional
            { source: 'enfoque_situacional', target: 'contexto', label: 'enfatiza' },
            { source: 'enfoque_situacional', target: 'adaptar_estilo', label: 'requiere' },
            { source: 'adaptar_estilo', target: 'contexto', label: 'según el' },
            { source: 'enfoque_situacional', target: 'hersey_blanchard', label: 'incluye' },
            { source: 'enfoque_situacional', target: 'contingencia', label: 'incluye' },
            { source: 'enfoque_situacional', target: 'camino_meta', label: 'incluye' },
            { source: 'enfoque_situacional', target: 'lmx', label: 'incluye' },

            // Hersey & Blanchard
            { source: 'hersey_blanchard', target: 'nivel_desarrollo', label: 'se basa en' },
            { source: 'hersey_blanchard', target: 'delegar', label: 'define estilo' },
            { source: 'hersey_blanchard', target: 'entrenar', label: 'define estilo' },
            { source: 'hersey_blanchard', target: 'dirigir', label: 'define estilo' },
            { source: 'hersey_blanchard', target: 'apoyar', label: 'define estilo' },
            { source: 'nivel_desarrollo', target: 'dirigir', label: 'bajo, requiere' },
            { source: 'nivel_desarrollo', target: 'entrenar', label: 'bajo-moderado, requiere' },
            { source: 'nivel_desarrollo', target: 'apoyar', label: 'moderado-alto, requiere' },
            { source: 'nivel_desarrollo', target: 'delegar', label: 'alto, requiere' },

            // Contingencia
            { source: 'contingencia', target: 'relacion_lider_seguidor', label: 'depende de' },
            { source: 'contingencia', target: 'estructura_tarea', label: 'depende de' },
            { source: 'contingencia', target: 'poder_lider', label: 'depende de' },
            { source: 'contingencia', target: 'lpc', label: 'usa' },
            { source: 'lpc', target: 'orientacion_empleado', label: 'mide' },
            { source: 'lpc', target: 'orientacion_produccion', label: 'mide' },
            
            // Camino-Meta
            { source: 'camino_meta', target: 'motivacion', label: 'enfocado en' },
            { source: 'motivacion', target: 'camino_meta', label: 'líder remueve obstáculos para' },
            { source: 'camino_meta', target: 'lider_directivo', label: 'define estilo' },
            { source: 'camino_meta', target: 'lider_considerado', label: 'define estilo' },
            { source: 'camino_meta', target: 'lider_participativo', label: 'define estilo' },
            { source: 'camino_meta', target: 'lider_metas', label: 'define estilo' },

            // LMX
            { source: 'lmx', target: 'relacion_lider_seguidor', label: 'se enfoca en' },
            { source: 'lmx', target: 'endogrupo', label: 'crea' },
            { source: 'lmx', target: 'exogrupo', label: 'crea' }
        ];

        const categoryColors = {
            root: new THREE.Color(0xff0044), // Rojo
            approach: new THREE.Color(0x0088ff), // Azul
            theory: new THREE.Color(0x00ff88), // Verde
            concept: new THREE.Color(0xff8800), // Naranja
            style: new THREE.Color(0xaa00ff), // Púrpura
            study: new THREE.Color(0xcccccc) // Gris
        };

        // --- INICIALIZACIÓN DE LA ESCENA 3D ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 50;
        camera.rotation.order = 'YXZ';
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING PARA EL EFECTO GLOW (BLOOM) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const BLOOM_LAYER = 1;

        // --- LUCES ---
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 2000);
        scene.add(pointLight);

        // --- FUNCIÓN PARA CREAR TEXTO (SPRITES) ---
        function makeTextSprite(message, opts) {
            const parameters = opts || {};
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const textColor = parameters.textColor || { r: 255, g: 255, b: 255, a: 1.0 };
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            canvas.width = textWidth + 10;
            canvas.height = fontsize + 10;
            context.font = `Bold ${fontsize}px ${fontface}`;
            context.fillStyle = `rgba(${textColor.r}, ${textColor.g}, ${textColor.b}, ${textColor.a})`;
            context.fillText(message, 5, fontsize - 2);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 4, canvas.height / 4, 1.0);
            return sprite;
        }

        // --- CREACIÓN DEL MAPA CONCEPTUAL 3D ---
        const nodeObjects = new Map();
        const nodeGeometry = new THREE.SphereGeometry(3, 24, 24);

        concepts.forEach(concept => {
            const color = categoryColors[concept.category] || new THREE.Color(0xffffff);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const nodeMesh = new THREE.Mesh(nodeGeometry, material);
            
            const nodeGroup = new THREE.Group();
            nodeGroup.position.x = (Math.random() - 0.5) * NETWORK_RADIUS;
            nodeGroup.position.y = (Math.random() - 0.5) * NETWORK_RADIUS;
            nodeGroup.position.z = (Math.random() - 0.5) * NETWORK_RADIUS;
            
            const labelSprite = makeTextSprite(concept.name, {
                fontsize: 24,
                textColor: { r: color.r * 255, g: color.g * 255, b: color.b * 255, a: 1.0 }
            });
            labelSprite.position.set(0, 6, 0);

            nodeGroup.add(nodeMesh);
            nodeGroup.add(labelSprite);
            nodeGroup.layers.enable(BLOOM_LAYER);
            
            scene.add(nodeGroup);
            nodeObjects.set(concept.id, nodeGroup);
        });

        relationships.forEach(rel => {
            const startNode = nodeObjects.get(rel.source);
            const endNode = nodeObjects.get(rel.target);
            if (!startNode || !endNode) return;

            const startColor = startNode.children[0].material.color;
            const points = [startNode.position, endNode.position];
            const linkGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const linkMaterial = new THREE.LineBasicMaterial({ color: startColor, transparent: true, opacity: 0.7 });
            const line = new THREE.Line(linkGeometry, linkMaterial);
            line.layers.enable(BLOOM_LAYER);
            scene.add(line);

            const midpoint = new THREE.Vector3().addVectors(startNode.position, endNode.position).multiplyScalar(0.5);
            const unionSprite = makeTextSprite(rel.label, {
                fontsize: 16,
                textColor: { r: 0, g: 200, b: 200, a: 0.9 }
            });
            unionSprite.position.copy(midpoint);
            unionSprite.layers.enable(BLOOM_LAYER);
            scene.add(unionSprite);
        });

        // --- CONTROLES ---
        const keyboard = {};
        const playerSpeed = 2.0;
        const rotationSpeed = 0.002;

        // Detectar dispositivo móvil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('gyro-btn').style.display = 'block';
        }

        // --- CONTROLES DE TECLADO ---
        document.addEventListener('keydown', (e) => keyboard[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keyboard[e.key.toLowerCase()] = false);

        // --- CONTROLES TÁCTILES ---
        const touchControls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        function setupTouchControl(btnId, direction) {
            const btn = document.getElementById(btnId);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls[direction] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls[direction] = false;
            });
        }

        setupTouchControl('btn-up', 'up');
        setupTouchControl('btn-down', 'down');
        setupTouchControl('btn-left', 'left');
        setupTouchControl('btn-right', 'right');

        // --- GIROSCOPIO ---
        let gyroEnabled = false;
        let lastAlpha = null;
        let lastBeta = null;

        async function enableGyro() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requiere permiso
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        startGyro();
                    } else {
                        console.log('Permiso para giroscopio denegado');
                    }
                } catch (error) {
                    console.error('Error al solicitar permiso:', error);
                    alert('No se pudo activar el giroscopio');
                }
            } else if (typeof DeviceOrientationEvent !== 'undefined') {
                // Android y otros navegadores
                startGyro();
            } else {
                console.log('Giroscopio no soportado');
                alert('Giroscopio no soportado en este dispositivo');
            }
        }

        function startGyro() {
            gyroEnabled = true;
            document.getElementById('gyro-btn').textContent = 'Giroscopio Activo';
            document.getElementById('gyro-btn').style.background = 'rgba(0, 255, 136, 0.5)';
            
            window.addEventListener('deviceorientation', handleOrientation);
        }

        function handleOrientation(event) {
            if (!gyroEnabled) return;

            const alpha = event.alpha; // Rotación Z (0-360)
            const beta = event.beta;   // Rotación X (-180 a 180)
            
            if (alpha !== null && beta !== null) {
                // Acumular cambios para rotación suave
                if (lastAlpha !== null && lastBeta !== null) {
                    // Invertir los giros: cambia el signo de los deltas
                    const deltaAlpha = -(alpha - lastAlpha) * Math.PI / 180;
                    const deltaBeta = -(beta - lastBeta) * Math.PI / 180;
                    
                    // Limitar beta para evitar inversión
                    const newBeta = camera.rotation.x - deltaBeta;
                    if (newBeta > -Math.PI/2 && newBeta < Math.PI/2) {
                        camera.rotation.x = newBeta;
                    }
                    camera.rotation.y -= deltaAlpha;
                }
                
                lastAlpha = alpha;
                lastBeta = beta;
            }

            // Actualizar display de depuración
            document.getElementById('gyro-alpha').textContent = alpha !== null ? alpha.toFixed(2) : 'N/A';
            document.getElementById('gyro-beta').textContent = beta !== null ? beta.toFixed(2) : 'N/A';
        }

        document.getElementById('gyro-btn').addEventListener('click', enableGyro);

        // --- CONTROL DE RATÓN (DESKTOP) ---
        document.addEventListener('mousemove', onDocumentMouseMove);

        function onDocumentMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * rotationSpeed;
                camera.rotation.x -= event.movementY * rotationSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function updatePlayer() {
            // Crear vector de dirección basado en la rotación de la cámara
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            // Controles de teclado - mover en la dirección de la cámara
            if (keyboard['w'] || keyboard['arrowup']) camera.position.addScaledVector(direction, playerSpeed);
            if (keyboard['s'] || keyboard['arrowdown']) camera.position.addScaledVector(direction, -playerSpeed);
            
            // Movimiento lateral (strafe) perpendicular a la dirección
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            if (keyboard['a'] || keyboard['arrowleft']) camera.position.addScaledVector(right, -playerSpeed);
            if (keyboard['d'] || keyboard['arrowright']) camera.position.addScaledVector(right, playerSpeed);
            
            // Controles táctiles (similar para consistencia)
            if (touchControls.up) camera.position.addScaledVector(direction, playerSpeed);
            if (touchControls.down) camera.position.addScaledVector(direction, -playerSpeed);
            if (touchControls.left) camera.position.addScaledVector(right, -playerSpeed);
            if (touchControls.right) camera.position.addScaledVector(right, playerSpeed);
        }
        
        // --- LOOP DE ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            pointLight.position.copy(camera.position);

            nodeObjects.forEach(node => {
                const label = node.children[1];
                if (label) {
                    label.quaternion.copy(camera.quaternion);
                }
            });

            // Actualizar display de depuración para la cámara
            document.getElementById('cam-x').textContent = (camera.rotation.x * 180 / Math.PI).toFixed(2);
            document.getElementById('cam-y').textContent = (camera.rotation.y * 180 / Math.PI).toFixed(2);

            composer.render();
        }

        // --- MANEJO DE VENTANA ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        if (!isMobile) {
            document.addEventListener('click', () => {
                document.body.requestPointerLock();
            });
        }

        animate();
    </script>
    <div id="crosshair"></div>
</body>
</html>